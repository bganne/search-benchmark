/*
%Z%  FILE: %M%  RELEASE: %I%  DATE: %G%, %U%
*/
/*******************************************************************************

Process:

    netecho.c

    Network Server to Echo Input.

Author:    Alex Measday, ISI


    Invocation:

        % netecho [-debug] [-sink] [-vperror] <server_name>

    where:

        "-debug"
            enables debug output.
        "-sink"
            puts NETECHO into "zero" mode, i.e., it acts as a data sink.
            All data received by NETECHO is discarded, not echoed back to
            the sender.
        "-vperror"
            turns VPERROR() message output on.  VPERROR() messages are
            low-level error messages generated by TPOCC library functions;
            normally, they are disabled.  If enabled, the messages are
            output to STDERR.
        "<server_name>"
            specifies the name of this server on this machine.  The server
            name should be present in the "/etc/services" system file.

*******************************************************************************/


#include  <errno.h>			/* System error definitions. */
#include  <netdb.h>			/* Network database definitions. */
#include  <signal.h>			/* Signal definitions. */
#include  <stdio.h>			/* Standard I/O definitions. */
#include  <stdlib.h>			/* Standard C Library definitions. */
#ifdef  sun
#    define  atexit(f)  on_exit (f, (char *) NULL)
#endif
#include  <string.h>			/* C Library string functions. */
#include  <sys/types.h>			/* System type definitions. */
#include  <sys/socket.h>		/* Socket-related definitions. */
#include  <netinet/in.h>		/* Internet IPC domain definitions. */
#ifdef vms
#    include  "fd.h"			/* File descriptor set definitions. */
#endif
#include  "opt_util.h"			/* Option scanning definitions. */
#include  "sigh_util.h"			/* Signal handling definitions. */
#include  "tcp_util.h"			/* TCP/IP utility definitions. */
#include  "vperror.h"			/* VPERROR() definitions. */

					/* Internal functions. */
static  void  exit_handler (), interrupt_handler () ;

#define  MAX_INPUT  (4*1024)

					/* Non-local variables. */
static  TcpPort  serverPort = NULL ;




main (argc, argv)

    int  argc ;
    char  *argv[] ;

{  /* Local variables. */
    char  *argument, input_buffer[MAX_INPUT], *server_name ;
    int  errflg, length, option, status, vperror_save, zero_mode ;
    int  client, num_clients = 0 ;
    fd_set  read_mask, read_mask_save ;
    TcpConnection  clientConnection[FD_SETSIZE] ;

    static  char  *option_list[] = {	/* Command line options. */
        "{debug}", "{sink}", "{vperror}", NULL
    } ;




    vperror_save = vperror_print ;	/* Save state of VPERROR_PRINT flag. */
    vperror_print = 1 ;			/* Enable VPERROR output during initialization. */


/* Set up a termination handler and an interrupt handler. */

    if (atexit (exit_handler))
        vperror ("Error declaring the exit handler: ") ;
    signal (SIGINT, interrupt_handler) ;
    signal (SIGTERM, interrupt_handler) ;
    signal (SIGPIPE, generic_handler) ;


/*******************************************************************************
    Scan the command line options.
*******************************************************************************/

    server_name = NULL ;
    if (strstr (argv[0], "netsink") == (char *) NULL)
        zero_mode = 0 ;		/* Program invoked as "netecho". */
    else
        zero_mode = 1 ;		/* Program invoked as "netsink". */


    opt_init (argc, argv, 1, option_list, NULL) ;
    errflg = 0 ;

    while (option = opt_get (NULL, &argument)) {

        switch (option) {
        case 1:			/* "-debug" */
            tcp_util_debug = 1 ;  vperror_save = 1 ;
            break ;
        case 2:			/* "-sink" */
            zero_mode = 1 ;
            break ;
        case 3:			/* "-vperror" */
            vperror_save = 1 ;
            break ;
        case NONOPT:		/* "<server>" */
            server_name = argument ;
            break ;
        case OPTERR:
        default:
            errflg++ ;  break ;
        }
    }

    if (errflg || (server_name == NULL)) {
        fprintf (stderr, "Usage:  netecho [-debug] [-sink] [-vperror] <server_name>\n") ;
        exit (-1) ;
    }


    if (server_name == (char *) NULL)
        server_name = zero_mode ? "netsink" : "netecho" ;


/* Create and bind a socket to the listening port. */

    if (tcpListen (server_name, -1, &serverPort)) {
        vperror ("[%s] Error creating listening port.\ntcpListen: ", argv[0]) ;
        exit (errno) ;
    }

/*******************************************************************************
    Field connection requests from new clients and service old clients.
*******************************************************************************/

    vperror_print = vperror_save ;	/* Set VPERROR() output flag. */

    for ( ; ; ) {

/* Monitor all the sockets for input. */

        FD_ZERO (&read_mask_save) ;
        FD_SET (tcpFd (serverPort), &read_mask_save) ;
        for (client = 0 ;  client < num_clients ;  client++)
            FD_SET (tcpFd (clientConnection[client]), &read_mask_save) ;

        for ( ; ; ) {
            read_mask = read_mask_save ;
            if (select (FD_SETSIZE, &read_mask, NULL, NULL, NULL) >= 0)  break ;
            if (errno == EINTR)  continue ;	/* SELECT interrupted by signal - try again. */
            vperror ("[%s] Error checking network for input.\nselect: ", argv[0]) ;
            exit (errno) ;
        }

 /* If a new client is requesting a connection, then accept the request and
    add the client to the list of clients. */

        if (FD_ISSET (tcpFd (serverPort), &read_mask)) {
            if (tcpAnswer (serverPort, -1.0,
                           &clientConnection[num_clients++])) {
                vperror ("[%s] Error answering connection request.\ntcpAnswer: ",
                         argv[0]) ;
                num_clients-- ;
            }
        }

/* Service any old clients that need to be serviced. */

        for (client = 0 ;  client < num_clients ;  client++) {
            if (FD_ISSET (tcpFd (clientConnection[client]), &read_mask)) {
                if (tcpRead (clientConnection[client], -1.0,
                             -sizeof input_buffer, input_buffer, &length)) {
                    vperror ("[%s] Error reading connection %s.\ntcpRead: ",
                             argv[0], tcpName (clientConnection[client])) ;
                    tcpClose (clientConnection[client]) ;
                    clientConnection[client] = clientConnection[--num_clients] ;
                } else {
                    if (!zero_mode)
                        tcpWrite (clientConnection[client], -1.0,
                                   length, input_buffer, &length) ;
                }
            }
        }

    }

}

/*******************************************************************************

  Termination Handler

*******************************************************************************/

#ifdef  sun
    static  void  exit_handler (status, arg)
        int  status ;
        char  *arg ;
#else
    static  void  exit_handler ()
#endif
{
    if (serverPort != NULL)  tcpClose (serverPort) ;
}

/*******************************************************************************

    Interrupt Handler.


    Invoked by the system in response to a SIGINT signal:

        interrupt_handler (sig, code, scp, addr)

    where

        (see SIGVEC(2) for detailed descriptions of arguments)

        <sig>   is the signal causing invocation of the handler.
        <code>  provides additional information for certain signals.
        <scp>   points to the signal context prior to the signal.
        <addr>  provides additional address information for certain signals.

*******************************************************************************/


static  void  interrupt_handler (sig, code, scp, addr)

    int  sig, code ;
    struct  sigcontext  *scp ;
    char  *addr ;

{
    exit (-1) ;
}
